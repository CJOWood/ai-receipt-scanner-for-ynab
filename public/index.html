<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YNAB Slip Uploader</title>
    <style>
      body {
        margin: 40px;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
  </head>
  <body>
    <div id="root"></div>

    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- react-hook-form -->
    <script src="https://unpkg.com/react-hook-form/dist/index.umd.js"></script>
    <!-- MUI and Emotion -->
    <script src="https://unpkg.com/@emotion/react@11/dist/emotion-react.umd.min.js"></script>
    <script src="https://unpkg.com/@emotion/styled@11/dist/emotion-styled.umd.min.js"></script>
    <script src="https://unpkg.com/@mui/material@5/umd/material-ui.production.min.js"></script>
    <!-- react-easy-crop -->
    <script src="https://unpkg.com/react-easy-crop@4/umd/react-easy-crop.min.js"></script>
    <!-- Expose runtime config -->
    <script src="/config.js"></script>
    <script>
      const { useState } = React;
      const { useForm, Controller } = ReactHookForm;
      const {
        TextField,
        Button,
        Container,
        Typography,
        Box,
        Autocomplete,
        createFilterOptions,
        Stepper,
        Step,
        StepLabel,
        StepContent,
        Checkbox,
        LoadingButton,
        Table,
        TableBody,
        TableCell,
        TableContainer,
        TableHead,
        TableRow,
        Paper,
        IconButton,
        Stack,
        Dialog,
        DialogTitle,
        DialogContent,
        DialogActions,
        Slider,
      } = MaterialUI;

      function App() {
        const authRequired = !window.APP_DISABLE_AUTH && !window.APP_TRUSTED_IPS;
        const { register, handleSubmit, reset, control, watch } = useForm();
        const fileRegister = register("file", { required: true });

        const [accounts, setAccounts] = useState(() => {
          const stored = localStorage.getItem("accounts");
          return stored ? JSON.parse(stored) : [];
        });
        const [fileName, setFileName] = useState("");
        const [loading, setLoading] = useState(false);
        const [openCrop, setOpenCrop] = useState(false);
        const [cropSrc, setCropSrc] = useState(null);
        const [fileToCrop, setFileToCrop] = useState(null);
        const [croppedFile, setCroppedFile] = useState(null);
        const [crop, setCrop] = useState({ x: 0, y: 0 });
        const [zoom, setZoom] = useState(1);
        const [croppedAreaPixels, setCroppedAreaPixels] = useState(null);
        const fileInputRef = React.useRef(null);
        const defaultSteps = [
          { label: "Uploading image", done: false, logs: [], error: null },
          { label: "Request to Gemini", done: false, logs: [], error: null },
          { label: "Response from Gemini", done: false, logs: [], error: null },
          { label: "Response from YNAB", done: false, logs: [], error: null },
        ];
        const defaultOpenSteps = [true, false, false, false];
        const [steps, setSteps] = useState(defaultSteps);
        const [openSteps, setOpenSteps] = useState(defaultOpenSteps);
        const [activeStep, setActiveStep] = useState(0);
        const watchAccount = watch("account");
        const watchFile = watch("file");
        const canSubmit = !!watchAccount && !!(watchFile && watchFile.length > 0);

        const addAccount = (acc) => {
          if (acc && !accounts.includes(acc)) {
            const updated = [...accounts, acc];
            setAccounts(updated);
            localStorage.setItem("accounts", JSON.stringify(updated));
          }
        };

        const removeAccount = (acc) => {
          const updated = accounts.filter((a) => a !== acc);
          setAccounts(updated);
          localStorage.setItem("accounts", JSON.stringify(updated));
        };

        const markStep = (index) => {
          setSteps((prev) => {
            const updated = [...prev];
            updated[index].done = true;
            return updated;
          });
          setOpenSteps((prev) => {
            const updated = [...prev];
            updated[index] = true;
            return updated;
          });
          setActiveStep(index + 1);
        };

        const markError = (index, message) => {
          setSteps((prev) => {
            const updated = [...prev];
            updated[index].error = message;
            return updated;
          });
          setOpenSteps((prev) => {
            const updated = [...prev];
            updated[index] = true;
            return updated;
          });
          setActiveStep(index);
        };

        const toggleStep = (index) => {
          setOpenSteps((prev) => {
            const updated = [...prev];
            updated[index] = !updated[index];
            return updated;
          });
        };

        const getCroppedBlob = async (src, crop) => {
          const image = await new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
          });
          const canvas = document.createElement("canvas");
          canvas.width = crop.width;
          canvas.height = crop.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(
            image,
            crop.x,
            crop.y,
            crop.width,
            crop.height,
            0,
            0,
            crop.width,
            crop.height,
          );
          return new Promise((resolve) =>
            canvas.toBlob((b) => resolve(b), fileToCrop.type || "image/jpeg")
          );
        };

        const applyCrop = async () => {
          if (!cropSrc || !croppedAreaPixels) {
            setOpenCrop(false);
            return;
          }
          const blob = await getCroppedBlob(cropSrc, croppedAreaPixels);
          const newFile = new File([blob], fileToCrop.name, { type: fileToCrop.type });
          const dt = new DataTransfer();
          dt.items.add(newFile);
          if (fileInputRef.current) {
            fileInputRef.current.files = dt.files;
          }
          setCroppedFile(newFile);
          setFileName(newFile.name);
          setOpenCrop(false);
        };

        const renderReceiptTable = (receipt, key) =>
          React.createElement(
            TableContainer,
            { component: Paper, key, sx: { mb: 1 } },
            React.createElement(
              Table,
              { size: "small" },
              React.createElement(
                TableHead,
                null,
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(
                    TableCell,
                    { colSpan: 4, sx: { fontWeight: "bold" } },
                    "Receipt Details"
                  )
                ),
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(
                    TableCell,
                    { colSpan: 2 },
                    `Merchant: ${receipt.merchant}`
                  ),
                  React.createElement(
                    TableCell,
                    { colSpan: 2 },
                    `Date: ${receipt.transactionDate}`
                  )
                ),
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(TableCell, null, "Item"),
                  React.createElement(TableCell, null, "Qty"),
                  React.createElement(TableCell, null, "Category"),
                  React.createElement(TableCell, null, "Amount")
                )
              ),
              React.createElement(
                TableBody,
                null,
                receipt.lineItems?.map((li, idx) =>
                  React.createElement(
                    TableRow,
                    { key: idx },
                    React.createElement(TableCell, null, li.productName),
                    React.createElement(TableCell, null, li.quantity ?? ""),
                    React.createElement(TableCell, null, li.category),
                    React.createElement(
                      TableCell,
                      null,
                      li.lineItemTotalAmount.toFixed(2)
                    )
                  )
                ),
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(TableCell, { colSpan: 3, align: "right" }, "Total"),
                  React.createElement(
                    TableCell,
                    null,
                    receipt.totalAmount.toFixed(2)
                  )
                )
              )
            )
          );

        const addLog = (index, message) => {
          setSteps((prev) => {
            const updated = [...prev];
            updated[index].logs.push(message);
            return updated;
          });
        };

        const onSubmit = async (data) => {
          if (!data.file?.[0]) {
            alert("Please select a file");
            return;
          }

          const file = croppedFile || data.file[0];

          setSteps(() => {
            const updated = defaultSteps.map((s) => ({ ...s }));
            updated[0].logs.push(
              `File: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`
            );
            return updated;
          });
          setOpenSteps(defaultOpenSteps);
          setActiveStep(0);
          setLoading(true);

          const formData = new FormData();
          formData.append("account", data.account);
          formData.append("file", file);

          const headers = {};
          if (authRequired) {
            const auth = btoa(`${data.apiKey}:${data.apiSecret}`);
            headers["Authorization"] = `Basic ${auth}`;
          }

          try {
            const res = await fetch("/upload/events", {
              method: "POST",
              headers,
              body: formData,
            });

            if (!res.body) {
              throw new Error("No response body");
            }

            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            let buffer = "";

            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });
              let parts = buffer.split("\n\n");
              buffer = parts.pop();
              for (const part of parts) {
                const line = part
                  .split("\n")
                  .find((l) => l.startsWith("data:"));
                if (line) {
                  const evt = JSON.parse(line.slice(5));
                  if (evt.event === "upload-start") {
                    addLog(0, "Uploading file");
                  } else if (evt.event === "categories-loaded") {
                    addLog(0, "Categories loaded");
                  } else if (evt.event === "payees-loaded") {
                    addLog(0, "Payees loaded");
                  } else if (evt.event === "upload-file-done") {
                    addLog(0, "File uploaded");
                    markStep(0);
                  } else if (evt.event === "request-gemini") {
                    addLog(1, evt.data);
                    markStep(1);
                  } else if (evt.event === "response-gemini") {
                    addLog(2, evt.data);
                    markStep(2);
                  } else if (evt.event === "request-ynab") {
                    addLog(3, "Creating YNAB transaction");
                  } else if (evt.event === "response-ynab") {
                    addLog(3, "YNAB transaction created");
                    markStep(3);
                  } else if (evt.event === "error") {
                    addLog(activeStep, evt.data || "Upload failed");
                    markError(activeStep, evt.data || "Upload failed");
                  }
                }
              }
            }

            if (res.ok) {
              reset();
              setFileName("");
            } else {
              addLog(activeStep, "Upload failed");
              markError(activeStep, "Upload failed");
            }
          } catch (err) {
            addLog(activeStep, err.message || "Network error");
            markError(activeStep, err.message || "Network error");
          } finally {
            setLoading(false);
          }
        };

        const filter = createFilterOptions();

        return React.createElement(
          Container,
          null,
          React.createElement(
            Typography,
            { variant: "h5", component: "h2", sx: { mb: 2 } },
            "YNAB Slip Uploader",
          ),
          React.createElement(
            "form",
            { onSubmit: handleSubmit(onSubmit) },
            authRequired &&
              React.createElement(
                Box,
                { sx: { mb: 2 } },
                React.createElement(TextField, {
                  label: "API Key",
                  fullWidth: true,
                  margin: "dense",
                  ...register("apiKey", { required: true }),
                }),
              ),
            authRequired &&
              React.createElement(
                Box,
                { sx: { mb: 2 } },
                React.createElement(TextField, {
                  label: "API Secret",
                  type: "password",
                  fullWidth: true,
                  margin: "dense",
                  ...register("apiSecret", { required: true }),
                }),
              ),
            React.createElement(
              Box,
              { sx: { mb: 2 } },
              React.createElement(Controller, {
                control,
                name: "account",
                rules: { required: true },
                render: ({ field }) =>
                  React.createElement(Autocomplete, {
                    freeSolo: true,
                    selectOnFocus: true,
                    clearOnBlur: true,
                    handleHomeEndKeys: true,
                    disabled: loading,
                    options: accounts.map((acc) => ({ title: acc })),
                    value: field.value ? { title: field.value } : null,
                    onChange: (event, newValue) => {
                      if (typeof newValue === "string") {
                        field.onChange(newValue);
                        addAccount(newValue);
                      } else if (newValue && newValue.inputValue) {
                        field.onChange(newValue.inputValue);
                        addAccount(newValue.inputValue);
                      } else if (newValue) {
                        field.onChange(newValue.title);
                      } else {
                        field.onChange("");
                      }
                    },
                    filterOptions: (options, params) => {
                      const filtered = filter(options, params);
                      const { inputValue } = params;
                      if (inputValue !== "" && !accounts.includes(inputValue)) {
                        filtered.push({
                          inputValue,
                          title: `Add "${inputValue}"`,
                        });
                      }
                      return filtered;
                    },
                    getOptionLabel: (option) => {
                      if (typeof option === "string") {
                        return option;
                      }
                      if (option.inputValue) {
                        return option.inputValue;
                      }
                      return option.title;
                    },
                    renderOption: (props, option) =>
                      React.createElement(
                        "li",
                        {
                          ...props,
                          style: {
                            display: "flex",
                            justifyContent: "space-between",
                            alignItems: "center",
                          },
                        },
                        option.title,
                        !option.inputValue &&
                          React.createElement(
                            "button",
                            {
                              type: "button",
                              onClick: (e) => {
                                e.stopPropagation();
                                removeAccount(option.title);
                              },
                              style: {
                                marginLeft: "8px",
                                border: "none",
                                background: "transparent",
                                cursor: "pointer",
                                fontSize: "0.8rem",
                              },
                            },
                            "\u00D7",
                          ),
                      ),
                      renderInput: (params) =>
                        React.createElement(TextField, {
                          ...params,
                          label: "Bank Account",
                          disabled: loading,
                        }),
                  }),
              }),
            ),
              React.createElement(
                Box,
                { sx: { mb: 2 } },
                React.createElement(
                  Stack,
                  { direction: "row", alignItems: "center", spacing: 1 },
                  React.createElement(
                    Button,
                    {
                      variant: "outlined",
                      component: "label",
                      htmlFor: "file-input",
                      disabled: loading,
                    },
                    "Select File"
                  ),
                  React.createElement(
                    IconButton,
                    {
                      color: "primary",
                      component: "label",
                      htmlFor: "file-input",
                      "aria-label": "take picture",
                      disabled: loading,
                    },
                    React.createElement(
                      "span",
                      { className: "material-icons" },
                      "photo_camera"
                    )
                  ),
                  fileName &&
                    React.createElement(
                      Typography,
                      { variant: "body2", sx: { ml: 2, display: "inline" } },
                      fileName
                    )
                ),
                React.createElement("input", {
                  id: "file-input",
                  type: "file",
                  hidden: true,
                  accept: ".jpg,.jpeg,.png,.webp,.pdf",
                  capture: "environment",
                  disabled: loading,
                  onChange: (e) => {
                    fileRegister.onChange(e);
                    const f = e.target.files?.[0];
                    setFileName(f?.name || "");
                    setCroppedFile(null);
                    setFileToCrop(f || null);
                    if (f && f.type.startsWith("image/")) {
                      setCropSrc(URL.createObjectURL(f));
                      setOpenCrop(true);
                    }
                  },
                  onBlur: fileRegister.onBlur,
                  name: fileRegister.name,
                  ref: (el) => {
                    fileRegister.ref(el);
                    fileInputRef.current = el;
                  },
                })
              ),
              React.createElement(
                Button,
                { variant: "contained", type: "submit", disabled: loading || !canSubmit },
                loading
                  ? React.createElement(MaterialUI.CircularProgress, { size: 24, color: "inherit" })
                  : "Upload"
              ),
            React.createElement(
              Stepper,
              { activeStep: activeStep, orientation: "vertical", sx: { mt: 2 } },
              steps.map((step, idx) =>
                React.createElement(
                  Step,
                  { key: idx, completed: step.done, expanded: openSteps[idx] },
                  React.createElement(
                    StepLabel,
                    {
                      onClick: () => toggleStep(idx),
                      error: !!step.error,
                      sx: {
                        cursor: "pointer",
                        "& .MuiStepIcon-root.Mui-completed": {
                          color: "success.main",
                        },
                        "& .MuiStepLabel-label.Mui-completed": {
                          color: "text.primary",
                        },
                      },
                    },
                    step.label
                  ),
                  React.createElement(
                    StepContent,
                    { TransitionProps: { unmountOnExit: false } },
                    step.logs.map((log, i) =>
                      typeof log === "object"
                        ? renderReceiptTable(log, i)
                        : React.createElement(
                            Typography,
                            {
                              variant: "caption",
                              key: i,
                              sx: {
                                display: "block",
                                whiteSpace: "pre",
                                color:
                                  step.error && i === step.logs.length - 1
                                    ? "error.main"
                                    : "inherit",
                              },
                            },
                            log
                          )
                    )
                  )
                )
              )
            ),
          ),
          React.createElement(
            Dialog,
            { open: openCrop, onClose: () => setOpenCrop(false), fullWidth: true, maxWidth: "sm" },
            React.createElement(DialogTitle, null, "Crop Image"),
            React.createElement(
              DialogContent,
              null,
              React.createElement(
                "div",
                {
                  style: { position: "relative", width: "100%", height: 400 },
                },
                React.createElement(ReactEasyCrop.default, {
                  image: cropSrc,
                  crop: crop,
                  zoom: zoom,
                  onCropChange: setCrop,
                  onZoomChange: setZoom,
                  onCropComplete: (_, areaPixels) => setCroppedAreaPixels(areaPixels),
                })
              ),
              React.createElement(Slider, {
                min: 1,
                max: 3,
                step: 0.1,
                value: zoom,
                onChange: (e, v) => setZoom(v),
                sx: { mt: 2 },
              })
            ),
            React.createElement(
              DialogActions,
              null,
              React.createElement(Button, { onClick: () => setOpenCrop(false) }, "Cancel"),
              React.createElement(Button, { onClick: applyCrop, variant: "contained" }, "Apply")
            )
          )
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(
        React.createElement(App),
      );
    </script>
  </body>
</html>
