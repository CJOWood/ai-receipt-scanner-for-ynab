<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YNAB Slip Uploader</title>
    <style>
      body {
        margin: 40px;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
  </head>
  <body>
    <div id="root"></div>

    <!-- React and ReactDOM -->
    <script src="/node_modules/react/umd/react.production.min.js"></script>
    <script src="/node_modules/react-dom/umd/react-dom.production.min.js"></script>
    <!-- react-hook-form -->
    <script src="/node_modules/react-hook-form/dist/index.umd.js"></script>
    <!-- MUI and Emotion -->
    <script src="/node_modules/@emotion/react/dist/emotion-react.umd.min.js"></script>
    <script src="/node_modules/@emotion/styled/dist/emotion-styled.umd.min.js"></script>
    <script src="/node_modules/@mui/material/umd/material-ui.production.min.js"></script>
    <!-- react-image-crop -->
    <link
      rel="stylesheet"
      href="/node_modules/react-image-crop/dist/ReactCrop.css"
    />
    <script src="/node_modules/react-image-crop/dist/index.umd.cjs"></script>
    <!-- smartcrop for automatic crop suggestions -->
    <script src="/node_modules/smartcrop/smartcrop.js"></script>
    <!-- Expose runtime config -->
    <script src="/config.js"></script>
    <script>
      const { useState } = React;
      const { useForm, Controller } = ReactHookForm;
      const {
        TextField,
        Button,
        Container,
        Typography,
        Box,
        Autocomplete,
        createFilterOptions,
        Stepper,
        Step,
        StepLabel,
        StepContent,
        Checkbox,
        LoadingButton,
        Table,
        TableBody,
        TableCell,
        TableContainer,
        TableHead,
        TableRow,
        Paper,
        IconButton,
        Stack,
        Dialog,
        DialogTitle,
        DialogContent,
        DialogActions,
      } = MaterialUI;

      function App() {
        const authRequired =
          !window.APP_DISABLE_AUTH && !window.APP_TRUSTED_IPS;
        const { register, handleSubmit, reset, control, watch } = useForm();
        const fileRegister = register("file", { required: true });

        const [accounts, setAccounts] = useState(() => {
          const stored = localStorage.getItem("accounts");
          return stored ? JSON.parse(stored) : [];
        });
        const [fileName, setFileName] = useState("");
        const [fileType, setFileType] = useState("");
        const [loading, setLoading] = useState(false);
        const defaultSteps = [
          { label: "Uploading image", done: false, logs: [], error: null },
          { label: "Request to Gemini", done: false, logs: [], error: null },
          { label: "Response from Gemini", done: false, logs: [], error: null },
          { label: "Response from YNAB", done: false, logs: [], error: null },
        ];
        const defaultOpenSteps = [true, false, false, false];
        const [steps, setSteps] = useState(defaultSteps);
        const [openSteps, setOpenSteps] = useState(defaultOpenSteps);
        const [activeStep, setActiveStep] = useState(0);
        const watchAccount = watch("account");
        const watchFile = watch("file");
        const canSubmit =
          !!watchAccount && !!(watchFile && watchFile.length > 0);
        const [cropOpen, setCropOpen] = useState(false);
        const [imgSrc, setImgSrc] = useState(null);
        const [crop, setCrop] = useState(null);
        const [completedCrop, setCompletedCrop] = useState(null);
        const [croppedFile, setCroppedFile] = useState(null);
        const [rotation, setRotation] = useState(0);
        const imgRef = React.useRef(null);

        const addAccount = (acc) => {
          if (acc && !accounts.includes(acc)) {
            const updated = [...accounts, acc];
            setAccounts(updated);
            localStorage.setItem("accounts", JSON.stringify(updated));
          }
        };

        const removeAccount = (acc) => {
          const updated = accounts.filter((a) => a !== acc);
          setAccounts(updated);
          localStorage.setItem("accounts", JSON.stringify(updated));
        };

        const markStep = (index) => {
          setSteps((prev) => {
            const updated = [...prev];
            updated[index].done = true;
            return updated;
          });
          setOpenSteps((prev) => {
            const updated = [...prev];
            updated[index] = true;
            return updated;
          });
          setActiveStep(index + 1);
        };

        const markError = (index, message) => {
          setSteps((prev) => {
            const updated = [...prev];
            updated[index].error = message;
            return updated;
          });
          setOpenSteps((prev) => {
            const updated = [...prev];
            updated[index] = true;
            return updated;
          });
          setActiveStep(index);
        };

        const toggleStep = (index) => {
          setOpenSteps((prev) => {
            const updated = [...prev];
            updated[index] = !updated[index];
            return updated;
          });
        };

        const handleFileChange = (e) => {
          fileRegister.onChange(e);
          setCroppedFile(null);
          setCrop(null);
          setCompletedCrop(null);
          setRotation(0);
          const f = e.target.files?.[0];
          setFileName(f?.name || "");
          setFileType(f?.type || "");
          if (f && f.type.startsWith("image/")) {
            const url = URL.createObjectURL(f);
            setImgSrc(url);
            const img = new Image();
            img.onload = async () => {
              const res = await window.smartcrop.crop(img, {
                width: img.width,
                height: img.height,
              });
              const c = res.topCrop;
              setCrop({
                unit: "px",
                x: c.x,
                y: c.y,
                width: c.width,
                height: c.height,
              });
              setCropOpen(true);
            };
            img.src = url;
          } else {
            setImgSrc(null);
          }
        };

        const rotateImage = async () => {
          if (!imgRef.current) return;
          const canvas = document.createElement("canvas");
          canvas.width = imgRef.current.naturalHeight;
          canvas.height = imgRef.current.naturalWidth;
          const ctx = canvas.getContext("2d");
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.rotate(Math.PI / 2);
          ctx.drawImage(
            imgRef.current,
            -imgRef.current.naturalWidth / 2,
            -imgRef.current.naturalHeight / 2,
          );
          const blob = await new Promise((res) =>
            canvas.toBlob(res, fileType || "image/jpeg", fileType === "image/jpeg" ? 1 : undefined),
          );
          if (blob) {
            const url = URL.createObjectURL(blob);
            setImgSrc(url);
            setRotation((r) => (r + 90) % 360);
            setCrop(null);
            setCompletedCrop(null);
            setCroppedFile(null);
            const img = new Image();
            img.onload = async () => {
              const res = await window.smartcrop.crop(img, {
                width: img.width,
                height: img.height,
              });
              const c = res.topCrop;
              setCrop({
                unit: "px",
                x: c.x,
                y: c.y,
                width: c.width,
                height: c.height,
              });
            };
            img.src = url;
          }
        };

        const applyCrop = async () => {
          if (!completedCrop || !imgRef.current) {
            setCropOpen(false);
            return;
          }
          const canvas = document.createElement("canvas");
          const scaleX = imgRef.current.naturalWidth / imgRef.current.width;
          const scaleY = imgRef.current.naturalHeight / imgRef.current.height;
          canvas.width = completedCrop.width;
          canvas.height = completedCrop.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(
            imgRef.current,
            completedCrop.x * scaleX,
            completedCrop.y * scaleY,
            completedCrop.width * scaleX,
            completedCrop.height * scaleY,
            0,
            0,
            completedCrop.width,
            completedCrop.height,
          );
          const blob = await new Promise((res) =>
            canvas.toBlob(res, fileType || "image/jpeg", fileType === "image/jpeg" ? 1 : undefined),
          );
            if (blob) {
              const url = URL.createObjectURL(blob);
              setCroppedFile(new File([blob], fileName, { type: fileType || "image/jpeg" }));
              setImgSrc(url);
            }
            setCropOpen(false);
          };

        const renderReceiptTable = (receipt, key) =>
          React.createElement(
            TableContainer,
            { component: Paper, key, sx: { mb: 1 } },
            React.createElement(
              Table,
              { size: "small" },
              React.createElement(
                TableHead,
                null,
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(
                    TableCell,
                    { colSpan: 4, sx: { fontWeight: "bold" } },
                    "Receipt Details",
                  ),
                ),
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(
                    TableCell,
                    { colSpan: 2 },
                    `Merchant: ${receipt.merchant}`,
                  ),
                  React.createElement(
                    TableCell,
                    { colSpan: 2 },
                    `Date: ${receipt.transactionDate}`,
                  ),
                ),
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(TableCell, null, "Item"),
                  React.createElement(TableCell, null, "Qty"),
                  React.createElement(TableCell, null, "Category"),
                  React.createElement(TableCell, null, "Amount"),
                ),
              ),
              React.createElement(
                TableBody,
                null,
                receipt.lineItems?.map((li, idx) =>
                  React.createElement(
                    TableRow,
                    { key: idx },
                    React.createElement(TableCell, null, li.productName),
                    React.createElement(TableCell, null, li.quantity ?? ""),
                    React.createElement(TableCell, null, li.category),
                    React.createElement(
                      TableCell,
                      null,
                      li.lineItemTotalAmount.toFixed(2),
                    ),
                  ),
                ),
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(
                    TableCell,
                    { colSpan: 3, align: "right" },
                    "Total",
                  ),
                  React.createElement(
                    TableCell,
                    null,
                    receipt.totalAmount.toFixed(2),
                  ),
                ),
              ),
            ),
          );

        const renderTransactionTable = (tx, key) =>
          React.createElement(
            TableContainer,
            { component: Paper, key, sx: { mb: 1 } },
            React.createElement(
              Table,
              { size: "small" },
              React.createElement(
                TableHead,
                null,
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(
                    TableCell,
                    { colSpan: 2, sx: { fontWeight: "bold" } },
                    "Transaction Details",
                  ),
                ),
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(
                    TableCell,
                    { colSpan: 2 },
                    `Account: ${tx.account}`,
                  ),
                ),
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(
                    TableCell,
                    { colSpan: 2 },
                    `Payee: ${tx.merchant}`,
                  ),
                ),
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(
                    TableCell,
                    { colSpan: 2 },
                    `Date: ${tx.transactionDate}`,
                  ),
                ),
                tx.memo &&
                  React.createElement(
                    TableRow,
                    null,
                    React.createElement(
                      TableCell,
                      { colSpan: 2 },
                      `Memo: ${tx.memo}`,
                    ),
                  ),
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(TableCell, null, "Category"),
                  React.createElement(TableCell, null, "Amount"),
                ),
              ),
              React.createElement(
                TableBody,
                null,
                tx.splits && tx.splits.length > 0
                  ? tx.splits.map((s, idx) =>
                      React.createElement(
                        TableRow,
                        { key: idx },
                        React.createElement(TableCell, null, s.category),
                        React.createElement(
                          TableCell,
                          null,
                          s.amount.toFixed(2),
                        ),
                      ),
                    )
                  : React.createElement(
                      TableRow,
                      null,
                      React.createElement(TableCell, null, tx.category),
                      React.createElement(
                        TableCell,
                        null,
                        tx.totalAmount.toFixed(2),
                      ),
                    ),
                React.createElement(
                  TableRow,
                  null,
                  React.createElement(TableCell, { align: "right" }, "Total"),
                  React.createElement(
                    TableCell,
                    null,
                    tx.totalAmount.toFixed(2),
                  ),
                ),
              ),
            ),
          );

        const addLog = (index, message) => {
          setSteps((prev) => {
            const updated = [...prev];
            updated[index].logs.push(message);
            return updated;
          });
        };

        const onSubmit = async (data) => {
          if (!data.file?.[0]) {
            alert("Please select a file");
            return;
          }

          const file = croppedFile || data.file[0];

          setSteps(() => {
            const updated = defaultSteps.map((s) => ({ ...s }));
            updated[0].logs.push(
              `File: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`,
            );
            return updated;
          });
          setOpenSteps(defaultOpenSteps);
          setActiveStep(0);
          setLoading(true);

          const formData = new FormData();
          formData.append("account", data.account);
          formData.append("file", file);

          const headers = {};
          if (authRequired) {
            const auth = btoa(`${data.apiKey}:${data.apiSecret}`);
            headers["Authorization"] = `Basic ${auth}`;
          }

          try {
            const res = await fetch("/upload/events", {
              method: "POST",
              headers,
              body: formData,
            });

            if (!res.body) {
              throw new Error("No response body");
            }

            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            let buffer = "";

            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });
              let parts = buffer.split("\n\n");
              buffer = parts.pop();
              for (const part of parts) {
                const line = part
                  .split("\n")
                  .find((l) => l.startsWith("data:"));
                if (line) {
                  const evt = JSON.parse(line.slice(5));
                  if (evt.event === "upload-start") {
                    addLog(0, "Uploading file");
                  } else if (evt.event === "categories-loaded") {
                    addLog(0, "Categories loaded");
                  } else if (evt.event === "payees-loaded") {
                    addLog(0, "Payees loaded");
                  } else if (evt.event === "upload-file-done") {
                    addLog(0, "File uploaded");
                    markStep(0);
                  } else if (evt.event === "request-gemini") {
                    addLog(1, evt.data);
                    markStep(1);
                  } else if (evt.event === "response-gemini") {
                    addLog(2, evt.data);
                    markStep(2);
                  } else if (evt.event === "request-ynab") {
                    addLog(3, "Creating YNAB transaction");
                  } else if (evt.event === "response-ynab") {
                    addLog(3, "YNAB transaction created");
                    if (evt.data) {
                      addLog(3, evt.data);
                    }
                    markStep(3);
                  } else if (evt.event === "error") {
                    addLog(activeStep, evt.data || "Upload failed");
                    markError(activeStep, evt.data || "Upload failed");
                  }
                }
              }
            }

            if (res.ok) {
              reset();
              setFileName("");
              setCroppedFile(null);
            } else {
              addLog(activeStep, "Upload failed");
              markError(activeStep, "Upload failed");
            }
          } catch (err) {
            addLog(activeStep, err.message || "Network error");
            markError(activeStep, err.message || "Network error");
          } finally {
            setLoading(false);
          }
        };

        const filter = createFilterOptions();

        return React.createElement(
          Container,
          null,
          React.createElement(
            Typography,
            { variant: "h5", component: "h2", sx: { mb: 2 } },
            "YNAB Slip Uploader",
          ),
          React.createElement(
            "form",
            { onSubmit: handleSubmit(onSubmit) },
            authRequired &&
              React.createElement(
                Box,
                { sx: { mb: 2 } },
                React.createElement(TextField, {
                  label: "API Key",
                  fullWidth: true,
                  margin: "dense",
                  ...register("apiKey", { required: true }),
                }),
              ),
            authRequired &&
              React.createElement(
                Box,
                { sx: { mb: 2 } },
                React.createElement(TextField, {
                  label: "API Secret",
                  type: "password",
                  fullWidth: true,
                  margin: "dense",
                  ...register("apiSecret", { required: true }),
                }),
              ),
            React.createElement(
              Box,
              { sx: { mb: 2 } },
              React.createElement(Controller, {
                control,
                name: "account",
                rules: { required: true },
                render: ({ field }) =>
                  React.createElement(Autocomplete, {
                    freeSolo: true,
                    selectOnFocus: true,
                    clearOnBlur: true,
                    handleHomeEndKeys: true,
                    disabled: loading,
                    options: accounts.map((acc) => ({ title: acc })),
                    value: field.value ? { title: field.value } : null,
                    onChange: (event, newValue) => {
                      if (typeof newValue === "string") {
                        field.onChange(newValue);
                        addAccount(newValue);
                      } else if (newValue && newValue.inputValue) {
                        field.onChange(newValue.inputValue);
                        addAccount(newValue.inputValue);
                      } else if (newValue) {
                        field.onChange(newValue.title);
                      } else {
                        field.onChange("");
                      }
                    },
                    filterOptions: (options, params) => {
                      const filtered = filter(options, params);
                      const { inputValue } = params;
                      if (inputValue !== "" && !accounts.includes(inputValue)) {
                        filtered.push({
                          inputValue,
                          title: `Add "${inputValue}"`,
                        });
                      }
                      return filtered;
                    },
                    getOptionLabel: (option) => {
                      if (typeof option === "string") {
                        return option;
                      }
                      if (option.inputValue) {
                        return option.inputValue;
                      }
                      return option.title;
                    },
                    renderOption: (props, option) =>
                      React.createElement(
                        "li",
                        {
                          ...props,
                          style: {
                            display: "flex",
                            justifyContent: "space-between",
                            alignItems: "center",
                          },
                        },
                        option.title,
                        !option.inputValue &&
                          React.createElement(
                            "button",
                            {
                              type: "button",
                              onClick: (e) => {
                                e.stopPropagation();
                                removeAccount(option.title);
                              },
                              style: {
                                marginLeft: "8px",
                                border: "none",
                                background: "transparent",
                                cursor: "pointer",
                                fontSize: "0.8rem",
                              },
                            },
                            "\u00D7",
                          ),
                      ),
                    renderInput: (params) =>
                      React.createElement(TextField, {
                        ...params,
                        label: "Bank Account",
                        disabled: loading,
                      }),
                  }),
              }),
            ),
            React.createElement(
              Box,
              { sx: { mb: 2 } },
              React.createElement(
                Stack,
                { direction: "row", alignItems: "center", spacing: 1 },
                React.createElement(
                  Button,
                  {
                    variant: "outlined",
                    component: "label",
                    htmlFor: "file-input",
                    disabled: loading,
                  },
                  "Select File",
                ),
                React.createElement(
                  IconButton,
                  {
                    color: "primary",
                    component: "label",
                    htmlFor: "camera-input",
                    "aria-label": "take picture",
                    disabled: loading,
                  },
                  React.createElement(
                    "span",
                    { className: "material-icons" },
                    "photo_camera",
                  ),
                ),
                fileName &&
                  React.createElement(
                    Typography,
                    { variant: "body2", sx: { ml: 2, display: "inline" } },
                    fileName,
                  ),
                imgSrc &&
                  React.createElement("img", {
                    src: imgSrc,
                    style: { maxWidth: 80, maxHeight: 80, marginLeft: 8 },
                  }),
              ),
              React.createElement("input", {
                id: "file-input",
                type: "file",
                hidden: true,
                accept: ".jpg,.jpeg,.png,.webp,.pdf",
                disabled: loading,
                onChange: handleFileChange,
                onBlur: fileRegister.onBlur,
                name: fileRegister.name,
                ref: fileRegister.ref,
              }),
              React.createElement("input", {
                id: "camera-input",
                type: "file",
                hidden: true,
                accept: "image/*",
                capture: "environment",
                disabled: loading,
                onChange: handleFileChange,
              }),
              React.createElement(
                Dialog,
                {
                  open: cropOpen,
                  onClose: () => setCropOpen(false),
                  maxWidth: "md",
                  fullWidth: true,
                },
                React.createElement(DialogTitle, null, "Crop Image"),
                React.createElement(
                  DialogContent,
                  { dividers: true },
                  imgSrc &&
                    React.createElement(
                      window.ReactCrop.ReactCrop,
                      {
                        crop: crop,
                        onChange: (c) => setCrop(c),
                        onComplete: (c) => setCompletedCrop(c),
                        keepSelection: true,
                      },
                      React.createElement("img", {
                        ref: imgRef,
                        src: imgSrc,
                        style: { maxWidth: "100%" },
                      }),
                    ),
                ),
                React.createElement(
                  DialogActions,
                  null,
                  React.createElement(
                    IconButton,
                    { onClick: rotateImage, sx: { mr: 1 } },
                    React.createElement(
                      "span",
                      { className: "material-icons" },
                      "rotate_right",
                    ),
                  ),
                  React.createElement(Button, { onClick: applyCrop }, "Done"),
                ),
              ),
            ),
            React.createElement(
              Button,
              {
                variant: "contained",
                type: "submit",
                disabled: loading || !canSubmit,
              },
              loading
                ? React.createElement(MaterialUI.CircularProgress, {
                    size: 24,
                    color: "inherit",
                  })
                : "Upload",
            ),
            React.createElement(
              Stepper,
              {
                activeStep: activeStep,
                orientation: "vertical",
                sx: { mt: 2 },
              },
              steps.map((step, idx) =>
                React.createElement(
                  Step,
                  { key: idx, completed: step.done, expanded: openSteps[idx] },
                  React.createElement(
                    StepLabel,
                    {
                      onClick: () => toggleStep(idx),
                      error: !!step.error,
                      sx: {
                        cursor: "pointer",
                        "& .MuiStepIcon-root.Mui-completed": {
                          color: "success.main",
                        },
                        "& .MuiStepLabel-label.Mui-completed": {
                          color: "text.primary",
                        },
                      },
                    },
                    step.label,
                  ),
                  React.createElement(
                    StepContent,
                    { TransitionProps: { unmountOnExit: false } },
                    step.logs.map((log, i) =>
                      typeof log === "object"
                        ? log.lineItems
                          ? renderReceiptTable(log, i)
                          : renderTransactionTable(log, i)
                        : React.createElement(
                            Typography,
                            {
                              variant: "caption",
                              key: i,
                              sx: {
                                display: "block",
                                whiteSpace: "pre",
                                color:
                                  step.error && i === step.logs.length - 1
                                    ? "error.main"
                                    : "inherit",
                              },
                            },
                            log,
                          ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(
        React.createElement(App),
      );
    </script>
  </body>
</html>
