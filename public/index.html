<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YNAB Slip Uploader</title>
    <style>
      body {
        margin: 40px;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- react-hook-form -->
    <script src="https://unpkg.com/react-hook-form/dist/index.umd.js"></script>
    <!-- MUI and Emotion -->
    <script src="https://unpkg.com/@emotion/react@11/dist/emotion-react.umd.min.js"></script>
    <script src="https://unpkg.com/@emotion/styled@11/dist/emotion-styled.umd.min.js"></script>
    <script src="https://unpkg.com/@mui/material@5/umd/material-ui.production.min.js"></script>
    <!-- Expose runtime config -->
    <script src="/config.js"></script>
    <script>
      const { useState } = React;
      const { useForm, Controller } = ReactHookForm;
      const {
        TextField,
        Button,
        Container,
        Typography,
        Box,
        Autocomplete,
        createFilterOptions,
        Stepper,
        Step,
        StepLabel,
        StepContent,
        Checkbox,
        LoadingButton,
      } = MaterialUI;

      function App() {
        const authRequired = !window.APP_FRONTEND_URL;
        const { register, handleSubmit, reset, control, watch } = useForm();
        const fileRegister = register("file", { required: true });

        const [accounts, setAccounts] = useState(() => {
          const stored = localStorage.getItem("accounts");
          return stored ? JSON.parse(stored) : [];
        });
        const [fileName, setFileName] = useState("");
        const [loading, setLoading] = useState(false);
        const defaultSteps = [
          { label: "Uploading image", done: false, logs: [] },
          { label: "Request to Gemini", done: false, logs: [] },
          { label: "Response from Gemini", done: false, logs: [] },
          { label: "Response from YNAB", done: false, logs: [] },
        ];
        const defaultOpenSteps = [true, false, false, false];
        const [steps, setSteps] = useState(defaultSteps);
        const [openSteps, setOpenSteps] = useState(defaultOpenSteps);
        const [activeStep, setActiveStep] = useState(0);
        const watchAccount = watch("account");
        const watchFile = watch("file");
        const canSubmit = !!watchAccount && !!(watchFile && watchFile.length > 0);

        const addAccount = (acc) => {
          if (acc && !accounts.includes(acc)) {
            const updated = [...accounts, acc];
            setAccounts(updated);
            localStorage.setItem("accounts", JSON.stringify(updated));
          }
        };

        const removeAccount = (acc) => {
          const updated = accounts.filter((a) => a !== acc);
          setAccounts(updated);
          localStorage.setItem("accounts", JSON.stringify(updated));
        };

        const markStep = (index) => {
          setSteps((prev) => {
            const updated = [...prev];
            updated[index].done = true;
            return updated;
          });
          setOpenSteps((prev) => {
            const updated = [...prev];
            updated[index] = true;
            return updated;
          });
          setActiveStep(index + 1);
        };

        const toggleStep = (index) => {
          setOpenSteps((prev) => {
            const updated = [...prev];
            updated[index] = !updated[index];
            return updated;
          });
        };

        const addLog = (index, message) => {
          setSteps((prev) => {
            const updated = [...prev];
            updated[index].logs.push(message);
            return updated;
          });
        };

        const onSubmit = async (data) => {
          if (!data.file?.[0]) {
            alert("Please select a file");
            return;
          }

          const file = data.file[0];

          setSteps(() => {
            const updated = defaultSteps.map((s) => ({ ...s }));
            updated[0].logs.push(
              `File: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`
            );
            return updated;
          });
          setOpenSteps(defaultOpenSteps);
          setActiveStep(0);
          setLoading(true);

          const formData = new FormData();
          formData.append("account", data.account);
          formData.append("file", data.file[0]);

          const headers = {};
          if (authRequired) {
            const auth = btoa(`${data.apiKey}:${data.apiSecret}`);
            headers["Authorization"] = `Basic ${auth}`;
          }

          try {
            const res = await fetch("/upload/events", {
              method: "POST",
              headers,
              body: formData,
            });

            if (!res.body) {
              throw new Error("No response body");
            }

            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            let buffer = "";

            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });
              let parts = buffer.split("\n\n");
              buffer = parts.pop();
              for (const part of parts) {
                const line = part
                  .split("\n")
                  .find((l) => l.startsWith("data:"));
                if (line) {
                  const evt = JSON.parse(line.slice(5));
                  if (evt.event === "upload-start") {
                    addLog(0, "Uploading file");
                  } else if (evt.event === "categories-loaded") {
                    addLog(0, "Categories loaded");
                  } else if (evt.event === "payees-loaded") {
                    addLog(0, "Payees loaded");
                  } else if (evt.event === "upload-file-done") {
                    addLog(0, "File uploaded");
                    markStep(0);
                  } else if (evt.event === "request-gemini") {
                    addLog(1, evt.data);
                    markStep(1);
                  } else if (evt.event === "response-gemini") {
                    addLog(2, JSON.stringify(evt.data, null, 2));
                    markStep(2);
                  } else if (evt.event === "request-ynab") {
                    addLog(3, "Creating YNAB transaction");
                  } else if (evt.event === "response-ynab") {
                    addLog(3, "YNAB transaction created");
                    markStep(3);
                  } else if (evt.event === "error") {
                    addLog(activeStep, evt.data || "Upload failed");
                  }
                }
              }
            }

            if (res.ok) {
              reset();
              setFileName("");
            } else {
              addLog(activeStep, "Upload failed");
            }
          } catch (err) {
            addLog(activeStep, err.message || "Network error");
          } finally {
            setLoading(false);
          }
        };

        const filter = createFilterOptions();

        return React.createElement(
          Container,
          null,
          React.createElement(
            Typography,
            { variant: "h5", component: "h2", sx: { mb: 2 } },
            "YNAB Slip Uploader",
          ),
          React.createElement(
            "form",
            { onSubmit: handleSubmit(onSubmit) },
            authRequired &&
              React.createElement(
                Box,
                { sx: { mb: 2 } },
                React.createElement(TextField, {
                  label: "API Key",
                  fullWidth: true,
                  margin: "dense",
                  ...register("apiKey", { required: true }),
                }),
              ),
            authRequired &&
              React.createElement(
                Box,
                { sx: { mb: 2 } },
                React.createElement(TextField, {
                  label: "API Secret",
                  type: "password",
                  fullWidth: true,
                  margin: "dense",
                  ...register("apiSecret", { required: true }),
                }),
              ),
            React.createElement(
              Box,
              { sx: { mb: 2 } },
              React.createElement(Controller, {
                control,
                name: "account",
                rules: { required: true },
                render: ({ field }) =>
                  React.createElement(Autocomplete, {
                    freeSolo: true,
                    selectOnFocus: true,
                    clearOnBlur: true,
                    handleHomeEndKeys: true,
                    disabled: loading,
                    options: accounts.map((acc) => ({ title: acc })),
                    value: field.value ? { title: field.value } : null,
                    onChange: (event, newValue) => {
                      if (typeof newValue === "string") {
                        field.onChange(newValue);
                        addAccount(newValue);
                      } else if (newValue && newValue.inputValue) {
                        field.onChange(newValue.inputValue);
                        addAccount(newValue.inputValue);
                      } else if (newValue) {
                        field.onChange(newValue.title);
                      } else {
                        field.onChange("");
                      }
                    },
                    filterOptions: (options, params) => {
                      const filtered = filter(options, params);
                      const { inputValue } = params;
                      if (inputValue !== "" && !accounts.includes(inputValue)) {
                        filtered.push({
                          inputValue,
                          title: `Add "${inputValue}"`,
                        });
                      }
                      return filtered;
                    },
                    getOptionLabel: (option) => {
                      if (typeof option === "string") {
                        return option;
                      }
                      if (option.inputValue) {
                        return option.inputValue;
                      }
                      return option.title;
                    },
                    renderOption: (props, option) =>
                      React.createElement(
                        "li",
                        {
                          ...props,
                          style: {
                            display: "flex",
                            justifyContent: "space-between",
                            alignItems: "center",
                          },
                        },
                        option.title,
                        !option.inputValue &&
                          React.createElement(
                            "button",
                            {
                              type: "button",
                              onClick: (e) => {
                                e.stopPropagation();
                                removeAccount(option.title);
                              },
                              style: {
                                marginLeft: "8px",
                                border: "none",
                                background: "transparent",
                                cursor: "pointer",
                                fontSize: "0.8rem",
                              },
                            },
                            "\u00D7",
                          ),
                      ),
                      renderInput: (params) =>
                        React.createElement(TextField, {
                          ...params,
                          label: "Bank Account",
                          disabled: loading,
                        }),
                  }),
              }),
            ),
            React.createElement(
              Box,
              { sx: { mb: 2 } },
              React.createElement(
                Button,
                { variant: "outlined", component: "label", disabled: loading },
                "Select File",
                React.createElement("input", {
                    type: "file",
                    hidden: true,
                    accept: ".jpg,.jpeg,.png,.webp,.pdf",
                    disabled: loading,
                  onChange: (e) => {
                    fileRegister.onChange(e);
                    setFileName(e.target.files?.[0]?.name || "");
                  },
                  onBlur: fileRegister.onBlur,
                  name: fileRegister.name,
                  ref: fileRegister.ref,
                })
              ),
              fileName &&
                React.createElement(
                  Typography,
                  { variant: "body2", sx: { ml: 2, display: "inline" } },
                  fileName
                )
            ),
              React.createElement(
                Button,
                { variant: "contained", type: "submit", disabled: loading || !canSubmit },
                loading
                  ? React.createElement(MaterialUI.CircularProgress, { size: 24, color: "inherit" })
                  : "Upload"
              ),
            React.createElement(
              Stepper,
              { activeStep: activeStep, orientation: "vertical", sx: { mt: 2 } },
              steps.map((step, idx) =>
                React.createElement(
                  Step,
                  { key: idx, completed: step.done, expanded: openSteps[idx] },
                  React.createElement(
                    StepLabel,
                    {
                      onClick: () => toggleStep(idx),
                      sx: {
                        cursor: "pointer",
                        "& .MuiStepIcon-root.Mui-completed": {
                          color: "success.main",
                        },
                        "& .MuiStepLabel-label.Mui-completed": {
                          color: "text.primary",
                        },
                      },
                    },
                    step.label
                  ),
                  React.createElement(
                    StepContent,
                    { TransitionProps: { unmountOnExit: false } },
                    step.logs.map((log, i) =>
                      React.createElement(
                        Typography,
                        { variant: "caption", key: i, sx: { display: "block" } },
                        log
                      )
                    )
                  )
                )
              )
            ),
          ),
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(
        React.createElement(App),
      );
    </script>
  </body>
</html>
